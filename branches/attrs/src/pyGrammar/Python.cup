
package pyGrammar;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import s2sCompiler.Program.AttrType;

init with {:
    // String buffer used to store output program
    outputBuffer = new StringBuffer();
    tabCounter = 0;
:};

parser code
{:
    // It can be "stdout" to write output program to standard
    // output or "file" to dump program in a file.
    public static String dumpOutput;

    // It's true if the semantic check is enabled
    public boolean enableSem = true;
    
    // String buffer used to store output program
    public StringBuffer outputBuffer;
    
     // counter used to count indentation level
    public static int tabCounter;

    // Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    public void syntax_error(Symbol cur_token){}

    // Return actual symbol
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // Return semantic value of symbol in position (position)
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
:}

action code
{:
	// Disable semantic check
    private void disableSem(){
        parser.enableSem = false;
    }
    // Return true if semantic is enabled, false otherwise
    private boolean sem(){
        return parser.enableSem;
    }
	// Error management
    private void pSemError(String message){
        System.err.println("SEM ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);

        parser.done_parsing();
    }
    private void pSemWarning(String message){
        System.err.println("SEM WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
    }
    private void pSynError(String message){
        System.err.println("SYN ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        parser.done_parsing();
    }
    private void pSynWarning(String message){
        System.err.println("SYN WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        /* Quando c'e' un errore sintattico continuo il parsing ma disabilito la semantica */
        disableSem();
    }
        
    // Write a string in output
    private void dump(String s){
        parser.outputBuffer.append(s);
    }
    private void dumpln(String s){
        parser.outputBuffer.append(s+"\n");
    }
    
    private int getIndentation()
    {
    	return ((PythonLex)parser.getScanner()).stackLength()-1; //-1 perche' ho lo zero
    }
    
    class Attributo {
    	
		public String name;
		public AttrType type;
		public Object value;

  	 	Attributo(String name, AttrType type, Object value){
			this.name = name;
			this.type = type;
			this.value = value;
    	}
		
		Attributo(String name, Object value){
				this.name = name;
				this.value = value;
        }
        
        Attributo(String name, AttrType type)
        {
        	this.name = name;
        	this.type = type;
        	this.value = new String(name);
        }

	    	//Nota: occorre ridefinire il metodo equals ereditato da Object al fine di	    
	    	//      di fornire a indexOf un metodo corretto per dire quando 2 oggetti
	    	//      sono uguali.
	    	public boolean equals(Object o){
			if((this.name).equals(((Attributo)o).name))return true;
    			else return false;
            	}
	};

:}

terminal        AND, AS, ASSERT, BREAK, CLASS, CONTINUE;
terminal        DEF, DEL, ELIF, ELSE, EXCEPT, EXEC, COMMENT;
terminal        FINALLY, FOR, FROM, GLOBAL, IF, IMPORT;
terminal        IN, IS, LAMBDA, NOT, OR, PASS,YIELD, TRIDOT, DIVDIV,NEWLINE, MULTMULT, INDENT, DEDENT;
terminal        PRINT, RAISE, RETURN, TRY, WHILE, WITH, RANGE;
terminal		PLUS, MINUS, MULT, DIVIDE, MOD, EXPON, DOT, MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ;
terminal		COMMA,SEMI,ASSIGN,COLON,LBRACK,RBRACK,LCURLY,RCURLY,LPAREN,RPAREN,TILDE,ECOM,PIPE,LSHIFT,RSHIFT;
terminal		AT,PLUSEQ,MINUSEQ,MULTEQ,DIVEQ,MODEQ,ANDEQ,OREQ,EXPEQ,RSEQ,LSEQ;
terminal		DECIMAL, LONGINT, HEX, OCT, BIN,FLOAT,IMAGNUM;
terminal String NAME, STRING;

non terminal	file_input, file_input_recoursive, stmt,simple_stmt, expr_stmt, print_stmt,del_stmt,flow_stmt,import_stmt, assert_stmt,global_stmt,exec_stmt;
non terminal	binop, unop;
non terminal	list_iter, list_for, list_if, name_recoursive, range_stmt;
non terminal	augassign, assign_recoursive, return_stmt,raise_stmt, dotted_name, dotted_as_name, dotted_as_names, import_as_name, import_as_names, dot_rec;
non terminal	arglist, subscriptlist, subscript,subscript_rec,sliceop,comp_for,comp_iter,comp_if, compound_stmt;
non terminal	if_stmt, while_stmt, for_stmt, try_stmt, with_stmt, funcdef, classdef, decorated, stmt_rec, small_stmt, small_stmt_rec;
non terminal	else_recoursive,except_clause, except_clause_recoursive, with_item, with_item_recoursive, decorator, decorators;
non terminal	Attributo atom,number, expr, comparison, test, defparameter, testlist, dictorsetmaker,testlist_comp,listmaker;
non terminal	Attributo lambdef, exprlist, argument,argument_rec,comment;
non terminal	LinkedList<Attributo> parameters, defparameter_recoursive, varargslist;
non terminal 	String trailer, suite;


/*Precedenza operatori: 
	lambda	Lambda expression
	if ï¿½ else	Conditional expression
	or	Boolean OR
	and	Boolean AND
	not x	Boolean NOT
	in, not in, is, is not, <, <=, >, >=, <>, !=, ==	Comparisons, including membership tests and identity tests,
	|	Bitwise OR
	^	Bitwise XOR
	&	Bitwise AND
	<<, >>	Shifts
	+, -	Addition and subtraction
	*, /, //, %	Multiplication, division, remainder [8]
	+x, -x, ~x	Positive, negative, bitwise NOT
	**	Exponentiation
*/
precedence left LAMBDA;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ, IN, IS;
precedence left PIPE;
precedence left EXPON;
precedence left ECOM;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, MOD;
precedence left TILDE;
precedence right MULTMULT;

/* Start symbols for the grammar:
*       single_input is a single interactive statement;
*       file_input is a module or sequence of commands read from an input file;
*       eval_input is the input for the eval() and input() functions.
* NB: compound_stmt in single_input is followed by extra NEWLINE!
*/

file_input	::= file_input_recoursive:f 
			{:
				try {
					if(f != null)
					{
						dumpln(f.toString());
						BufferedWriter out = new BufferedWriter(new FileWriter(parser.dumpOutput));
						String outText = parser.outputBuffer.toString();
						out.write(outText);
						out.close();
					}
				}
	            catch (IOException e)
	            {
	            	e.printStackTrace();
	            }
			:};
file_input_recoursive		::= NEWLINE file_input_recoursive:f {:RESULT = "\n"+f;:}
								| stmt:s file_input_recoursive:f 
								{:
									if(s==null && f!=null)
										RESULT= f.toString();
									else if (s!=null && f == null)
										RESULT = s.toString();
									else if (s!=null && f != null)
										RESULT = s.toString() + f.toString();
								:}
								| {:RESULT = "";:}
								;
								
funcdef		::= DEF NAME:n parameters:p COLON suite:s 
			{:
				boolean vararg = false;
				String asyouwant = 
				    "function #{ID}(#{PARAMS})\n"
				  + "#{BODY}";
				
				asyouwant = asyouwant.replaceAll("#\\{ID\\}", n);
				
				if (p == null)
					p = new LinkedList<Attributo>();
				
				for (Attributo a : p)
				{
					switch (a.type)
					{
						case ID:
							asyouwant = asyouwant.replaceAll("#\\{PARAMS\\}", a.name+",#{PARAMS}");
							break;
						/* *args */
						case LIST:
							if (!vararg)
							{
								asyouwant = asyouwant.replaceAll("#\\{PARAMS\\}", "#{PARAMS}...");
								vararg = true;
							}
							
							String args = 
							    "\tlocal "+a.name+" = { }\n"
							  + "\tfor i = 1,#arg-1 do\n"
							  + "\t\t"+a.name+"[i] = arg[i]\n"
							  + "\tend\n"
							  + "#{BODY}";
							
							asyouwant = asyouwant.replaceAll("#\\{BODY\\}", args);
							break;
						/* **kwargs */
						case DICT:
							if (!vararg)
							{
								asyouwant = asyouwant.replaceAll("#\\{PARAMS\\}", "...");
								vararg = true;
							}
							
							String kwargs = 
							    "\tlocal "+a.name+" = arg[#arg]\n"
							  + "#{BODY}";
							
							asyouwant = asyouwant.replaceAll("#\\{BODY\\}", kwargs);
							break;
						case ASSIGN:
							String init = 
							    "\tlocal "+a.name+"\n"
							  + "#{BODY}";
							
							asyouwant = asyouwant.replaceAll("#\\{PARAMS\\}", a.name.split("=")[0] +",#{PARAMS}");
							asyouwant = asyouwant.replaceAll("#\\{BODY\\}", init);
							break;
					}
				}
				asyouwant = asyouwant.replaceAll("#\\{PARAMS\\}", "");
				asyouwant = asyouwant.replaceAll(",\\)", ")");
				asyouwant = asyouwant.replaceAll("#\\{BODY\\}", s);
				
				RESULT = asyouwant;
			:};
parameters		::= LPAREN RPAREN {::} 
					| LPAREN varargslist:v RPAREN 
					{:
						RESULT = v;
					:}
					;

varargslist	::= defparameter_recoursive:d 
				{:
					RESULT = d; 
				:}
				| defparameter_recoursive:d COMMA MULT NAME:n 
				{:
					d.add(new Attributo(n,AttrType.LIST));
					RESULT = d;
				:}
				| defparameter_recoursive:d COMMA MULTMULT NAME:n 
				{:
					d.add(new Attributo(n,AttrType.DICT));
					RESULT = d;
				:}
				| defparameter_recoursive:d COMMA MULT NAME:n1 COMMA MULTMULT NAME:n2
				{:
					d.add(new Attributo(n1,AttrType.LIST));
					d.add(new Attributo(n2,AttrType.DICT));
					RESULT = d;
				:}
				| MULT NAME:n 
				{:
					LinkedList<Attributo> list = new LinkedList<Attributo>();
					list.add(new Attributo(n,AttrType.LIST));
					RESULT = list; 
				:}
				| MULT NAME:n1 COMMA MULTMULT NAME:n2 
				{:
					LinkedList<Attributo> list = new LinkedList<Attributo>();
					list.add(new Attributo(n1,AttrType.LIST));
					list.add(new Attributo(n2,AttrType.DICT));
					RESULT = list;
				:}
				| MULTMULT NAME:n 
				{:
					LinkedList<Attributo> list = new LinkedList<Attributo>();
					list.add(new Attributo(n,AttrType.DICT));
					RESULT = list; 
				:}
				;
defparameter_recoursive	::= defparameter:d 
							{:
								LinkedList<Attributo> list = new LinkedList<Attributo>();
								list.add(d);
								RESULT=list;
							:}
							| defparameter_recoursive:dr COMMA defparameter:d   
							{:
								dr.add(d);
								RESULT = dr;
							:} 
							;
defparameter	::= NAME:n 
					{:
						RESULT = new Attributo(n,AttrType.ID);
					:} 
					| NAME:n ASSIGN test:t 
					{:
						RESULT=new Attributo(n+"="+n+" or "+t.name, AttrType.ASSIGN);
					:}
					;

stmt			::= simple_stmt:s {:RESULT = s;:} 
					| compound_stmt:compound 
					{:
						RESULT = compound + "end\n";
					:}
					;

simple_stmt		::= small_stmt:s NEWLINE {:RESULT = s.toString()+"\n";:} 
					| small_stmt:s SEMI NEWLINE {:RESULT = s.toString()+";\n";:}
					| small_stmt:s small_stmt_rec:srec NEWLINE {:RESULT = s.toString()+ srec.toString() + "\n";:}
					| small_stmt:s small_stmt_rec:srec SEMI NEWLINE {:RESULT = s.toString()+ srec.toString() + ";\n";:}
					;
small_stmt_rec	::= SEMI small_stmt:s {:RESULT = ";"+s.toString();:} 
					| small_stmt_rec:srec SEMI small_stmt:s {:RESULT = srec.toString()+";"+s.toString();:}
					;
small_stmt		::= expr_stmt:e 
					{:
						RESULT = e.toString();
					:}
					| print_stmt:p 
					{:
						RESULT = p.toString();
					:}
					| range_stmt:r {:RESULT = r.toString();:}
					| del_stmt:d {:RESULT=d;:}
					| PASS:p {:RESULT=p; System.out.println("Found PASS_stmt");:}
					| flow_stmt:f 
					{:
						RESULT = f;
					:}
					| import_stmt:i 
					{:
						pSemWarning("Found import_stmt not supported in LUA");
						RESULT = "--[[Import not supported in LUA\n"+i+"]]";
					:}
         			| assert_stmt:a {:System.out.println("Found assert_stmt"); RESULT = a;:}
         			| global_stmt:g 
         			{:
         				pSemWarning("Found global_stmt not supported in LUA");
         				RESULT = "--[[Global not supported in LUA\n"+g+"]]";
         			:}
         			| comment:c {:RESULT = c.name;:}
	                ;
expr_stmt	::= testlist:t {:	RESULT=t.name;	:}
				| testlist:t1 augassign:a testlist:t2 
				{:
					//poiche' lua non supporta le assegnazioni +=, *=, /=, -=, **=, ^= si deve modificare la regola
					//String split[] = a.toString().split("=");
					RESULT = t1.name + "=" +t1.name+a+ t2.name;
				:}
				| testlist:t1 ASSIGN testlist:t2
				{:
					if(((LinkedList<Attributo>)t1.value).size() == ((LinkedList<Attributo>)t2.value).size())
						RESULT = t1.name +"="+t2.name;
					else if(((LinkedList<Attributo>)t1.value).size() == 1 && ((LinkedList<Attributo>)t2.value).size()>1)
						RESULT = t1.name +"= {"+t2.name+"}";
					else
						pSemError("Error in assignment");				
				:}
				;
augassign		::= PLUSEQ {:RESULT="+";:}| MINUSEQ {:RESULT="-";:} | MULTEQ {:RESULT="*";:} 
					| DIVEQ {:RESULT="/";:} | MODEQ {:RESULT="%";:} | ANDEQ {:RESULT=" and ";:} 
					| OREQ {:RESULT=" or ";:} | EXPEQ {:RESULT="^";:} | RSEQ {:RESULT="<<";:} | LSEQ {:RESULT=">>";:}
					;

print_stmt	::= PRINT {:RESULT = "print ";:} 
				| PRINT testlist:t {:RESULT = "print (" + t.name+")";:}
				| PRINT testlist:t COMMA {:RESULT = "print (" + t.name+")";:}
				;
range_stmt	::= RANGE LPAREN expr:e1 COMMA expr:e2 COMMA expr:e3 RPAREN {:RESULT = new String[]{e1.name,e2.name,e3.name};:}
				| RANGE LPAREN expr:e1 COMMA expr:e2 RPAREN {:RESULT = new String[]{e1.name,e2.name};:}
				;
del_stmt	::= DEL exprlist:explist {:RESULT = explist.name+" = nil";:};

flow_stmt	::= BREAK {:RESULT = "break ";:}
				| CONTINUE {:pSemWarning("LUA doesn't support continue statement");RESULT = "--[[LUA doesn't support continue statement\ncontinue]]";:}
				| return_stmt:r {:RESULT = r;:}
				| raise_stmt:r {:pSemWarning("Found raise statement, not supported in LUA"); RESULT = "--[[LUA doesn't support raise statement\n"+r+"]]";:}
				;
return_stmt		::= RETURN testlist:t {:RESULT = "return " + t.name;:};
raise_stmt	::= RAISE test:t {:RESULT = "raise " + t;:}
				| RAISE test:t1 COMMA test:t2 {:RESULT = "raise " + t1 + ","+t2;:}
				| RAISE test:t1 COMMA test:t2 COMMA test:t3 {:RESULT = "raise " + t1 + ","+t2+","+t3;:}
				;
import_stmt				::= IMPORT dotted_as_names:d {:RESULT = "import " + d;:}
							| FROM dotted_name:d IMPORT MULT {:RESULT = "from " + d + " import*";:}
							| FROM dotted_name:d IMPORT LPAREN import_as_names:i RPAREN {:RESULT = "from " + d+" import("+i+")";:}
							| FROM dotted_name:d IMPORT import_as_names:i {:RESULT = "from " + d+" import "+i;:}
							| FROM dot_rec:d dotted_name:n IMPORT MULT {:RESULT = "from " + d+n+" import*";:}
							| FROM dot_rec:d dotted_name:n IMPORT LPAREN import_as_names:i RPAREN {:RESULT = "from " + d+n+" import("+i+")";:}
							| FROM dot_rec:d dotted_name:n IMPORT import_as_names:i {:RESULT = "from " + d+n+" import "+i;:}
							| FROM DOT dot_rec:d IMPORT MULT {:RESULT = "from." + d+" import*";:}
							| FROM DOT dot_rec:d IMPORT LPAREN import_as_names:i RPAREN {:RESULT = "from." + d+" import("+i.toString()+")";:}
							| FROM DOT dot_rec:d IMPORT import_as_names:i {:RESULT = "from." + d+" import "+i;:}
							;
dotted_as_names			::= dotted_as_name:d {:RESULT=d;:} | dotted_as_names:ds COMMA dotted_as_name:d   {:RESULT=ds+","+d;:};
dotted_as_name			::= dotted_name:d {:RESULT=d;:} | dotted_name:d AS NAME:n {:RESULT = d+"as"+n;:};
dotted_name				::= NAME:n {:RESULT=n;:} | NAME:n DOT dotted_name:d {:RESULT=n+"."+d;:};
import_as_names			::= import_as_name:i {:RESULT= i;:} | import_as_name:i COMMA import_as_names:is {:RESULT=i+","+is;:};
import_as_name			::= NAME:n {:RESULT=n;:} | NAME:n1 AS NAME:n2 {:RESULT=n1+"as"+n2;:};
dot_rec					::= DOT {:RESULT=".";:} |  DOT dot_rec:d {:RESULT="."+d;:};
global_stmt				::= GLOBAL name_recoursive:n {:RESULT="global "+n.toString();:};
name_recoursive			::= NAME:n {:RESULT=n;:} | name_recoursive:nr COMMA NAME:n {:RESULT=nr+","+n;:};
assert_stmt				::= ASSERT testlist:t {:RESULT = "assert (" + t.name + ")";:};

compound_stmt	::= if_stmt:if_stmt {:RESULT = if_stmt; System.out.println(if_stmt);:}
					| while_stmt:w {:RESULT = w.toString();:}
					| for_stmt:f {:RESULT = f.toString();:}
					| try_stmt:t 
					{:
						pSynWarning("Try statement not supported in LUA");
						RESULT = "--[[Try statement not supported in LUA\n" + t.toString() + "]]";
					:}
					| funcdef:f {:System.out.println("funcdef: " + f); RESULT = f.toString();:}
					;
if_stmt		::= IF test:t COLON suite:s else_recoursive:else_rec 
				{:
					RESULT ="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s + else_rec;
				:}
				| IF test:t COLON suite:s 
				{:
					RESULT ="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s;
				:}
				| IF test:t COLON suite:s1 ELSE COLON suite:s2 
				{:
					RESULT="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s1 + "else " + s2;
				:}
				| IF test:t COLON suite:s1 else_recoursive:else_rec ELSE COLON suite:s2 
				{:
					RESULT="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s1 + else_rec + "else " + s2;
				:}
				| IF test:t error suite:s1 
				{:
					pSynWarning("Error ':' expected in 'if' instruction");
					RESULT ="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s1;
				:}
				| IF test:t error suite:s1 else_recoursive:else_rec 
				{:
					pSynWarning("Error ':' expected in 'if' instruction");
					RESULT ="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s1 + else_rec;
				:}
				| IF test:t error suite:s1 else_recoursive:else_rec ELSE COLON suite:s2
				{:
					pSynWarning("Error ':' expected in 'if' instruction");
					RESULT="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s1 + else_rec + "else " + s2;
				:}
				| IF test:t COLON suite:s1 ELSE error suite:s2
				{:
					pSynWarning("Error ':' expected in 'else' instruction");
					RESULT="if " + t.name.replaceAll("[\\{\\}]","") + " then " + s1 + "else " + s2;
				:}
				;
else_recoursive		::= ELIF test:t COLON suite:s 
						{:
							RESULT = "elseif " + t.name.replaceAll("[\\{\\}]","") + " then " + s;
						:}
						| else_recoursive:else_rec ELIF test:t COLON suite:s  
						{:
							RESULT =else_rec + "elseif " + t.name.replaceAll("[\\{\\}]","") + " then " + s;
						:}
						| ELIF test:t error suite:s 
						{:
							pSynWarning("Error ':' expected in 'elif' instruction");
							RESULT = "elseif " + t.name.replaceAll("[\\{\\}]","") + " then " + s;
						:}
						;
while_stmt	::= WHILE test:t COLON suite:s 
				{:					
					RESULT = "while " + t.name.replaceAll("[\\{\\}]","") + " do " + s.toString();
				:}
				| WHILE test:t error suite:s 
				{:
					pSynWarning("Error ':' expected in 'while' instruction");
					RESULT = "while " + t.name.replaceAll("[\\{\\}]","") + " do " + s;
				:}
				;
for_stmt	::= FOR expr:e IN test:t COLON suite:s
				{:
					if (t.type == AttrType.DICT)
						RESULT = "for " + e.name + " in pairs(" + t.name + ") do " + s;
					else
						RESULT = "for __k, " + e.name + " in pairs(" + t.name + ") do " + s;
				:} 
				| FOR exprlist:e IN range_stmt:r COLON suite:s 
				{:
					String[] range = (String[])r;
					if(range.length == 3)
						RESULT = "for " + e.name + "=" + range[0]+","+range[1] + "-1," + range[2]+" do " + s;
					else
						RESULT = "for " + e.name + "=" + range[0]+","+range[1]+"-1 do " + s;
				:}
				| FOR exprlist:e IN testlist:t error suite:s 
				{:
					pSynWarning("Error ':' expected in 'for' instruction"); disableSem();
					if (t.type == AttrType.DICT)
						RESULT = "for " + e.name + " in pairs(" + t.name + ") do " + s;
					else
						RESULT = "for __k, " + e.name + " in pairs(" + t.name + ") do " + s;
				:}
				| FOR exprlist:e IN range_stmt:r error suite:s 
				{:
					pSynWarning("Error ':' expected in 'for' instruction"); disableSem();
					String[] range = (String[])r;
					if(range.length == 3)
						RESULT = "for " + e.name + "=" + range[0]+","+range[1] + "-1," + range[2]+" do " + s;
					else
						RESULT = "for " + e.name + "=" + range[0]+","+range[1]+"-1 do " + s;
				:}
				;
try_stmt	::= TRY COLON suite:s1 FINALLY COLON suite:s2 {:RESULT = "try:" + s1 + "finally:"+s2;:}
				| TRY COLON suite:s1 except_clause_recoursive:excrec {:RESULT = "try:" + s1 + excrec;:}
				| TRY COLON suite:s1 except_clause_recoursive:excrec ELSE COLON suite:s2 {:RESULT = "try:" + s1 + excrec + "else:"+s2;:}
				| TRY COLON suite:s1 except_clause_recoursive:excrec FINALLY COLON suite:s2 {:RESULT = "try:" + s1 + excrec + "finally:" + s2;:}
				| TRY COLON suite:s1 except_clause_recoursive:excrec ELSE COLON suite:s2 FINALLY COLON suite:s3 {:RESULT = "try:" + s1 + excrec + "else:"+s2 + "finally:" + s3;:}
				;
except_clause_recoursive ::= except_clause:ec COLON suite:s {:RESULT = ec+":"+s;:} | except_clause_recoursive:ecrec except_clause:ec COLON suite:s {:RESULT = ecrec+""+ec+":"+s;:};
except_clause			::= EXCEPT {:RESULT = "except";:}
						| EXCEPT test:t {:RESULT = "except " + t;:}
						| EXCEPT test:t AS test:t2 {:RESULT = "except " + t + " as "+t2;:}
						| EXCEPT test:t1 COMMA test:t2 {:RESULT = "except " + t1 + "," + t2;:}
						;
						
suite	::= simple_stmt:simple {:System.out.println("suite simple: " + simple.toString());RESULT = "\n"+simple.toString();:} 
			| NEWLINE INDENT stmt_rec:s DEDENT 
			{:
				String t = ((String)s).replaceAll("\n", "\n\t"); 
				RESULT = "\n\t" + t + "\n";
			:}
			;
							
stmt_rec	::= stmt:s 
				{:
					RESULT = s.toString();
				:} 
				| stmt_rec:sr stmt:s 
				{:
					RESULT = sr.toString() + s.toString();
				:}
				;


test		::= comparison:c {:RESULT = c;:} | lambdef:l {:RESULT = l;:};
comparison	::= expr:e 
				{:
					RESULT = e;
				:} 
				| comparison:comparison binop:binop expr:e  
				{:
					comparison.name = comparison.name + binop.toString() + e.name;
					comparison.type = AttrType.OPERATION;
					RESULT = comparison;
				:}
				;
expr		::= atom:a {:RESULT = a;:} 
				| atom:a trailer:t 
				{:
					a.name = a.name + t;
					RESULT = a;
				:}
				;
atom		::= NAME:n {:RESULT = new Attributo(n,AttrType.ID);:} 
				| number:n {:RESULT = n;:} 
				| STRING:s {:RESULT = new Attributo(s,AttrType.STRING);:}
				| unop:u  atom:a  
				{:
					a.name = u.toString() + a.name;
					RESULT = a;
				:}
				| LPAREN RPAREN {:RESULT=new Attributo("{}",AttrType.TUPLE, new LinkedList<Attributo>());:}
				| LBRACK RBRACK {:RESULT=new Attributo("{}",AttrType.LIST, new LinkedList<Attributo>());:}
				| LCURLY RCURLY {:RESULT=new Attributo("{}",AttrType.DICT, new LinkedList<Attributo>());:}
				| LPAREN testlist_comp:t RPAREN 
				{:
					RESULT = new Attributo ("{"+t.name+"}",AttrType.TUPLE,(LinkedList<Attributo>)t.value);
				:}
				| LBRACK listmaker:l RBRACK 
				{:
					l.name = "{"+l.name+"}";
					l.type = AttrType.LIST;
					RESULT = l;
				:}
				| LCURLY dictorsetmaker:d RCURLY 
				{:
					d.name = "{"+d.name+"}";
					RESULT = d;
				:}
				| LPAREN error {:pSynWarning("Error invalid syntax"); RESULT=new Attributo("{",AttrType.TUPLE, new LinkedList<Attributo>());:}
				| LCURLY error {:pSynWarning("Error invalid syntax"); RESULT=new Attributo("{",AttrType.DICT, new LinkedList<Attributo>());:}
				| LPAREN testlist_comp:t error 
				{:
					pSynWarning("Error ')' expected after testlist");
					RESULT=new Attributo("{"+t.name+"}",AttrType.TUPLE, (LinkedList<Attributo>)t.value);
				:}
				| LBRACK error 
				{:
					pSynWarning("Error invalid syntax");
					RESULT=new Attributo("{",AttrType.LIST, new LinkedList<Attributo>());				
				:}
				| LCURLY dictorsetmaker:d error 
				{:
					pSynWarning("Error invalid syntax");
					RESULT=new Attributo("{"+d.name,AttrType.DICT, (LinkedList<Attributo>)d.value);
				:}
				;
testlist_comp	::= testlist:tlist{:RESULT = tlist;:};
/* Listmaker per la creazione di liste */
listmaker		::= testlist:tlist{:RESULT = tlist;:};
/* Dictionary maker e Set maker pre creare i dizionari oppure gli insiemi. */
dictorsetmaker	::= test:t1 COLON test:t2 
				{:
					t1.name = t1.name.replaceAll("[\"\']","");
					Attributo n = new Attributo(t1.name + "="+t2.name, AttrType.ASSIGN);
					Attributo a = new Attributo(n.name, AttrType.DICT,  new LinkedList<Attributo>());
					((LinkedList<Attributo>)a.value).add(n);
					RESULT = a;
				:}
				| dictorsetmaker:dic COMMA test:t1 COLON test:t2 
				{:
					t1.name = t1.name.replaceAll("[\"\']","");
					Attributo n = new Attributo(t1.name + "="+t2.name, AttrType.ASSIGN);
					dic.name = dic.name + "," + n.name;
					((LinkedList<Attributo>)dic.value).add(n);
					RESULT = dic;
				:}
				;
testlist	::= test:t 
				{:
					Attributo lista = new Attributo(t.name, new LinkedList<Attributo>());
					((LinkedList<Attributo>)lista.value).add(t);
					RESULT = lista;
				:}
				| testlist:tl COMMA test:t 
				{:
					((LinkedList<Attributo>)tl.value).add(t);
					tl.name = tl.name + ", "+t.name;
					RESULT = tl;
				:}
				;
exprlist	::= expr:e 
				{:
					Attributo lista = new Attributo(e.name, new LinkedList<Attributo>());
					((LinkedList<Attributo>)lista.value).add(e);
					RESULT = lista;
				:}
				|exprlist:explist COMMA expr:e 
				{:
					((LinkedList<Attributo>)explist.value).add(e);
					explist.name = explist.name + ", "+e.name;
					RESULT = explist;
				:}
				;

/* Le lambda form hanno la stessa posizione sintattica delle espressioni e servono per creare funzioni anonime. */
lambdef		::= LAMBDA COLON test:t {:RESULT = new Attributo("function() return "+t.name+" end",AttrType.LAMBDA);:};

trailer	::= LPAREN RPAREN {:RESULT = "()";:}
			| LPAREN arglist:a RPAREN {:RESULT = "("+a+")";:}
			| LBRACK RBRACK {:RESULT = "[]";:}
			| LBRACK testlist:tl RBRACK 
			{:
				StringBuilder sb = new StringBuilder();
				
				for (Attributo att: (LinkedList<Attributo>)tl.value)
				{
					if(att.type == AttrType.NUMBER)
					{
						att.name = ""+(Integer.parseInt(att.name)+1);
						sb.append(att.name);
						sb.append(",");
					}
					else
					{
						sb.append(att.name);
						sb.append(",");
					}
				}
				tl.name = sb.deleteCharAt(sb.length() - 1).toString();
				RESULT = "[" + tl.name + "]";
			:}
			| DOT NAME:n {:RESULT = "."+n.toString();:}
			;

arglist	::= argument:a
			{:
				RESULT = a.name;
			:}
			| argument_rec:ar
			{:
				RESULT = ar.name.replace(",$","");
			:}
			| MULT test:t
			{:
				if (t.type == AttrType.DICT)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: passing a dictionary after '*'");
					pSemError("Error: passing a dictionary after '*'");
				}
				RESULT = "unpack("+t.name+")"; 
			:}
			| MULT test:t COMMA argument_rec:ar argument:a
			{:
				if (t.type == AttrType.DICT)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: passing a dictionary after '*'");
					pSemError("Error: passing a dictionary after '*'");
				}
				RESULT = "unpack("+t.name+"),"+ar.name+a.name;
			:}
			| MULT test:t1 COMMA MULTMULT test:t2
			{:
				if (t1.type != AttrType.LIST && t1.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass list after '*'");
					pSemError("Error: must pass list after '*'");
				}
				if (t2.type != AttrType.DICT && t2.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass dict after '**'");
					pSemError("Error: must pass dict after '**'");
				}
				RESULT = "unpack("+t1.name+"),"+t2.name;
			:}
			| MULT test:t1 COMMA argument_rec:ar argument:a COMMA MULTMULT test:t2
			{:
				if (t1.type != AttrType.LIST && t1.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass list after '*'");
					pSemError("Error: must pass list after '*'");
				}
				if (t2.type != AttrType.DICT && t2.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass dict after '**'");
					pSemError("Error: must pass dict after '**'");
				}
				else
					RESULT = "unpack("+t1.name+"),"+ar.name+a.name+","+t2.name;
			:}
			| MULTMULT test:t 
			{:
				if (t.type == AttrType.LIST)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass dict after '**'");
					pSemError("Error: must pass dict after '**'");
				}
				RESULT = t.name;
			:}
			| argument_rec:ar argument:a
			{:
				RESULT = ar.name + a.name;
			:}
			| argument_rec:ar1 MULT test:t
			{:
				if (t.type == AttrType.DICT)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: passing a dictionary after '*'");
					pSemError("Error: passing a dictionary after '*'");
				}
				RESULT = ar1.name+"unpack("+t.name+")";
			:}
			| argument_rec:ar1 MULT test:t COMMA argument_rec:ar2 argument:a
			{:
				if (t.type == AttrType.DICT)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: passing a dictionary after '*'");
					pSemError("Error: passing a dictionary after '*'");
				}
				RESULT = ar1.name+"unpack("+t.name+"),"+ar2.name+a.name;
			:}
			| argument_rec:ar MULT test:t1 COMMA MULTMULT test:t2
			{:
				if (t1.type != AttrType.LIST && t1.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass list after '*'");
					pSemError("Error: must pass list after '*'");
				}
				if (t2.type != AttrType.DICT && t2.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass dict after '**'");
					pSemError("Error: must pass dict after '**'");
				}
				RESULT = ar.name+"unpack("+t1.name+"),"+t2.name;
			:}
			| argument_rec:ar1 MULT test:t1 COMMA argument_rec:ar2 argument:a COMMA MULTMULT test:t2
			{:
				if (t1.type != AttrType.LIST && t1.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass list after '*'");
					pSemError("Error: must pass list after '*'");
				}
				if (t2.type != AttrType.DICT && t2.type != AttrType.ID)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass dict after '**'");
					pSemError("Error: must pass dict after '**'");
				}
				RESULT = ar1.name+"unpack("+t1.name+"),"+ar2.name+a.name+","+t2.name;
			:}
			| argument_rec:ar MULTMULT test:t
			{:
				if (t.type == AttrType.LIST)
				{
					//throw new Exception("Error: passing a dictionary with '*'");
					//pSynWarning("Error: must pass dict after '**'");
					pSemError("Error: must pass dict after '**'");
				}
				RESULT = ar.name+t.name;
			:}
			;
argument_rec ::= argument:a COMMA
				{:
					Attributo lista = new Attributo(a.name+",", new LinkedList<Attributo>());
					((LinkedList<Attributo>)lista.value).add(a);
					RESULT = lista;
				:}
				| argument_rec:ar argument:a COMMA
				{:
					((LinkedList<Attributo>)ar.value).add(a);
					ar.name = ar.name+a.name+",";
					RESULT = ar;
				:}
				;
argument	::= test:t {:RESULT = t;:} 
				| test:t1 ASSIGN test:t2 
				{:
					if(t1.type==AttrType.STRING)
						t1.name = t1.name.replaceAll("[\"\']","");
					RESULT = new Attributo(t1.name+"="+t2.name,AttrType.ASSIGN);
				:}
				;

binop 	::= PLUS:p {:RESULT = p;:} | MINUS:m {:RESULT = m;:}| MULT:m {:RESULT = m;:}
		| DIVIDE:d {:RESULT = d;:}| EXPON:ex {:RESULT = ex;:}| MOD:m {:RESULT = m;:}
		| IS:is {:RESULT = "==";:}| IN:in {:RESULT = " in ";:}| IS NOT:isnot {:RESULT = "~=";:}
		| NOT IN:notin {:RESULT = notin;:}| LSHIFT:lshift {:RESULT = lshift;:}| RSHIFT: rshift{:RESULT = rshift;:}
 		| MINOR:min {:RESULT = min;:}| MINEQ:mineq {:RESULT = mineq;:}| MAIOR:mag {:RESULT = mag;:}
		| MAIEQ:maieq {:RESULT = maieq;:}| EQ:eq {:RESULT = eq;:}| NEQ {:RESULT = "~=";:}
 		| AND {:RESULT = " and ";:}| OR {:RESULT = " or ";:}| MULTMULT {:RESULT = "^";:}| NOT:not{:RESULT = not;:}
 		| PIPE:p {:RESULT=" or ";:}|ECOM:ec {:RESULT=" and ";:}|DIVDIV {:RESULT = "/";:}
 		;
unop	::= MINUS:m {:RESULT=m;:} | PLUS:p {:RESULT=p;:} | TILDE:t {:RESULT=t;:};
number	::= FLOAT:f {:RESULT = new Attributo(f.toString(), AttrType.NUMBER);:} 
		| IMAGNUM:i {:RESULT = new Attributo(i.toString(), AttrType.NUMBER);:}
		| LONGINT:li {:RESULT =new Attributo(li.toString(), AttrType.NUMBER); :} 
		| DECIMAL:i {:RESULT =new Attributo(i.toString(), AttrType.NUMBER);:}
		| HEX:i	{:RESULT =new Attributo(i.toString(), AttrType.NUMBER); :} 
		| OCT:i {:RESULT =new Attributo(i.toString(), AttrType.NUMBER); :}
		| BIN:i {:RESULT =new Attributo(i.toString(), AttrType.NUMBER); :}
		;
comment		::= COMMENT:c {:RESULT = new Attributo(c.toString().replace("#","--"),AttrType.COMMENT);:};