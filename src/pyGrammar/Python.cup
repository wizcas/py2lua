
package pyGrammar;

import java_cup.runtime.*;

parser code
{:
:}

action code
{:
:}

terminal        AND, AS, ASSERT, BREAK, CLASS, CONTINUE;
terminal        DEF, DEL, ELIF, ELSE, EXCEPT, EXEC;
terminal        FINALLY, FOR, FROM, GLOBAL, IF, IMPORT;
terminal        IN, IS, LAMBDA, NOT, OR, PASS;
terminal        PRINT, RAISE, RETURN, TRY, WHILE, WITH;
terminal        YIELD, TRIDOT, DIVDIV;
terminal		PLUS, MINUS, MULT, DIVIDE, MOD, EXPON, DOT, MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ;
terminal		COMMA,SEMI,ASSIGN,COLON,LBRACK,RBRACK,LCURLY,RCURLY,LPAREN,RPAREN,TILDE,ECOM,PIPE,LSHIFT,RSHIFT;
terminal		AT,PLUSEQ,MINUSEQ,MULTEQ,DIVEQ,MODEQ,ANDEQ,OREQ,EXPEQ,RSEQ,LSEQ;
terminal		STRING, DECIMAL, LONGINT, HEX, OCT, BIN,FLOAT,IMAGNUM;
terminal        NAME, NEWLINE, MULTMULT, INDENT, DEDENT;

non terminal	atom, literal,list_for, list_iter, list_if,or_test, comp_for, comp_iter, comp_if;
non terminal	power, shift_expr, and_expr, xor_expr, and_test, not_test, file_input, file_input_recoursive, stmt, number;
non terminal	simple_stmt, compound_stmt, del_stmt, print_stmt, return_stmt, raise_stmt, flow_stmt, global_stmt, expr_stmt;
non terminal	assert_stmt, pass_stmt, import_stmt, exec_stmt,comparison, comp_operator;
non terminal	assign_testlist_rec, assign_yield_rec, testlist, augassign, yield_expr;
non terminal	test_recoursive, test, exprlist, dotted_name, import_as_names, dotted_as_name, name_recoursive;
non terminal	import_name, import_from, dotted_as_names, dot_recoursive, import_as_name, except_clause_recoursive, except_clause;
non terminal	expr, if_stmt, while_stmt, for_stmt, with_stmt,try_stmt, funcdef, classdef, decorated, else_recoursive, suite;
non terminal	with_item, with_item_recoursive, stmt_recoursive, lambdef;
non terminal	arith_expr, term, factor, trailer_recoursive, trailer, testlist_comp, listmaker,dictorsetmaker, varargslist, arglist, subscriptlist, subscript, sliceop, test_comma_colon_rec;
non terminal	argument, argument_rec, testlist_safe, old_test, old_lambdef, decorator, decorators, parameters;
non terminal	fpdef_recoursive, fpdef, fplist, comma_test_rec, dictmakerclause, setmakerclause;

/*Precedenza operatori: 
	lambda	Lambda expression
	if – else	Conditional expression
	or	Boolean OR
	and	Boolean AND
	not x	Boolean NOT
	in, not in, is, is not, <, <=, >, >=, <>, !=, ==	Comparisons, including membership tests and identity tests,
	|	Bitwise OR
	^	Bitwise XOR
	&	Bitwise AND
	<<, >>	Shifts
	+, -	Addition and subtraction
	*, /, //, %	Multiplication, division, remainder [8]
	+x, -x, ~x	Positive, negative, bitwise NOT
	**	Exponentiation
*/
precedence left LAMBDA;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ, IN, IS;
precedence left PIPE;
precedence left EXPON;
precedence left ECOM;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, MOD;
precedence left TILDE;
precedence left MULTMULT;

file_input                ::= file_input_recoursive;

file_input_recoursive     ::= NEWLINE file_input_recoursive
                            | stmt file_input_recoursive
                            |
                            ;

decorator				::= AT dotted_name NEWLINE 
							| AT dotted_name LPAREN RPAREN NEWLINE
							| AT dotted_name LPAREN arglist RPAREN NEWLINE
							;
decorators				::= decorator | decorator decorators;
decorated				::= decorators classdef | decorators funcdef;
funcdef					::= DEF NAME parameters COLON suite;

parameters				::= LPAREN varargslist RPAREN;
/*
varargslist: ((fpdef ['=' test] ',')*
              ('*' NAME [',' '**' NAME] | '**' NAME) |
              fpdef ['=' test] (',' fpdef ['=' test])* [','])
*/
              
varargslist				::= MULT NAME 
							| MULT NAME COMMA MULTMULT NAME 
							| MULTMULT NAME
							| fpdef_recoursive MULT NAME
							| fpdef_recoursive MULT NAME COMMA MULTMULT NAME
							| fpdef_recoursive MULTMULT NAME
							| fpdef 
							| fpdef ASSIGN test
							| fpdef_recoursive
							;
fpdef_recoursive		::= fpdef COMMA 
							| fpdef ASSIGN test COMMA 
							| fpdef COMMA fpdef_recoursive 
							| fpdef ASSIGN test COMMA fpdef_recoursive
							;
fpdef					::= NAME | LPAREN fplist RPAREN;
fplist					::= fpdef COMMA | fpdef COMMA fplist;

stmt                    ::= simple_stmt | simple_stmt SEMI | compound_stmt ;

simple_stmt				::= expr_stmt
							| print_stmt
							| del_stmt
							| pass_stmt
							| flow_stmt
							| import_stmt
                 			| assert_stmt
                 			| global_stmt
                 			| exec_stmt
			                ;

expr_stmt			::= testlist
						| testlist augassign yield_expr
						| testlist augassign testlist
						| testlist assign_yield_rec
						| testlist assign_testlist_rec
						;
assign_yield_rec	::= ASSIGN yield_expr | ASSIGN yield_expr assign_yield_rec;
assign_testlist_rec ::= ASSIGN testlist test | ASSIGN testlist assign_testlist_rec;
augassign			::= PLUSEQ | MINUSEQ | MULTEQ | DIVEQ | MODEQ | ANDEQ | OREQ | EXPEQ | RSEQ | LSEQ;
/*Per l'assegnamento standard vengono applicate dall'interprete restrizioni aggiuntive*/
print_stmt			::= PRINT test_recoursive test
						| PRINT test_recoursive
						| PRINT RSHIFT test 
						| PRINT RSHIFT test_recoursive 
						| PRINT RSHIFT test_recoursive test
						;
test_recoursive		::= test COMMA | test COMMA test_recoursive;

del_stmt			::= DEL exprlist;
pass_stmt			::= PASS;
flow_stmt			::= BREAK 
						| CONTINUE 
						| return_stmt 
						| raise_stmt 
						| yield_expr
						;
return_stmt			::= RETURN testlist;
raise_stmt			::= RAISE test | RAISE test COMMA test | RAISE test COMMA test COMMA test;

import_stmt			::= import_name | import_from;
import_name			::= IMPORT dotted_as_names;
import_from			::= FROM dotted_name IMPORT MULT
						| FROM dotted_name IMPORT LPAREN import_as_names RPAREN
						| FROM dotted_name IMPORT import_as_names
						| FROM dot_recoursive dotted_name IMPORT MULT
						| FROM dot_recoursive dotted_name IMPORT LPAREN import_as_names RPAREN
						| FROM dot_recoursive dotted_name IMPORT import_as_names
						| FROM dot_recoursive IMPORT MULT
						| FROM dot_recoursive IMPORT LPAREN import_as_names RPAREN
						| FROM dot_recoursive IMPORT import_as_names
						;
dot_recoursive		::= DOT | DOT dot_recoursive;
import_as_name		::= NAME | NAME AS NAME;
dotted_as_name		::= dotted_name | dotted_name AS NAME;
dotted_name			::= NAME | NAME DOT dotted_name;
import_as_names		::= import_as_name | import_as_name COMMA import_as_names;
dotted_as_names		::= dotted_as_name | dotted_as_name COMMA dotted_as_names;

global_stmt			::= GLOBAL name_recoursive;
name_recoursive		::= NAME | NAME COMMA name_recoursive;

exec_stmt			::= EXEC expr | EXEC expr IN test | EXEC expr IN test COMMA test; 
assert_stmt			::= ASSERT test | ASSERT test COMMA test;

compound_stmt		::= if_stmt
						| while_stmt
						| for_stmt
						| try_stmt
						| with_stmt
						| funcdef
						| classdef
						| decorated
						;

if_stmt				::= IF test COLON suite else_recoursive
						| IF test COLON suite
						| IF test COLON suite ELSE COLON suite
						| IF test COLON suite else_recoursive ELSE COLON suite
						;
else_recoursive		::= ELIF test COLON suite | ELIF test COLON suite else_recoursive;

while_stmt			::= WHILE test COLON suite | WHILE test COLON suite ELSE COLON suite;
for_stmt			::= FOR exprlist IN testlist COLON suite | FOR exprlist IN testlist COLON suite ELSE COLON suite;
try_stmt			::= TRY COLON suite FINALLY COLON suite
					| TRY COLON suite except_clause_recoursive
					| TRY COLON suite except_clause_recoursive ELSE COLON suite
					| TRY COLON suite except_clause_recoursive FINALLY COLON suite
					| TRY COLON suite except_clause_recoursive ELSE COLON suite FINALLY COLON suite
					;
except_clause_recoursive ::= except_clause COLON suite | except_clause COLON suite except_clause_recoursive;
except_clause			::= EXCEPT 
						| EXCEPT test 
						| EXCEPT test AS test 
						| EXCEPT test COMMA test;

with_stmt				::= WITH with_item_recoursive COLON suite;
with_item_recoursive	::= with_item | with_item COMMA with_item_recoursive;
with_item				::= test | test AS expr;
suite					::= simple_stmt | NEWLINE INDENT stmt_recoursive DEDENT;
stmt_recoursive			::= stmt | stmt stmt_recoursive;

testlist_safe			::= old_test;
old_test				::= or_test | old_lambdef;
old_lambdef				::= LAMBDA COLON old_test | LAMBDA varargslist COLON old_test;

test					::= or_test | lambdef;

/*Operazioni booleane*/
or_test					::= and_test | and_test OR or_test ;
and_test				::= not_test | and_test AND not_test;
not_test				::= comparison;
comparison				::= expr | expr comp_operator comparison;
comp_operator 			::=  MINOR | MAIOR | EQ | MAIEQ | MINEQ | NEQ
                   			| IS | IS NOT | IN | NOT IN;
expr					::= xor_expr | xor_expr PIPE expr;
/*Operazioni binarie bit a bit*/
xor_expr				::= and_expr | and_expr EXPON xor_expr;
and_expr				::= shift_expr | shift_expr ECOM and_expr;
shift_expr				::= arith_expr | arith_expr LSHIFT shift_expr | arith_expr RSHIFT shift_expr;
arith_expr				::= term | term PLUS arith_expr | term MINUS arith_expr;
term					::= factor
							| factor MULT term
							| factor DIVIDE term
							| factor MOD term
							| factor DIVDIV term
						;
factor					::= PLUS factor
							| MINUS factor
							| TILDE	factor
							| power
							;
power					::= atom | atom MULTMULT factor | atom trailer_recoursive | atom trailer_recoursive MULTMULT factor;				
trailer_recoursive		::= trailer | trailer trailer_recoursive;
/*
Atoms elementi base delle espressioni. I più semplici
sono identificatori e letterali, anche le espressioni racchiuse
tra parentesi sono considerate atoms.
*/
atom					::= LPAREN RPAREN
							| LPAREN yield_expr RPAREN
							| LPAREN testlist_comp RPAREN
							| LBRACK RBRACK
							| LBRACK listmaker RBRACK
							| LCURLY RCURLY
							| LCURLY dictorsetmaker RCURLY //manca 'testlist1'
							| NAME | literal;
literal					::= STRING | number;
listmaker				::= test list_for | test test_recoursive | test test_recoursive COMMA;
testlist_comp			::= test comp_for | test test_recoursive;
lambdef					::= LAMBDA COLON test | LAMBDA varargslist COLON test;
trailer					::= LPAREN RPAREN | LPAREN arglist RPAREN
							| LBRACK RBRACK | LBRACK subscriptlist RBRACK
							| DOT NAME;
subscriptlist			::= subscript | subscript COMMA subscriptlist;
subscript				::= TRIDOT
							| test
							| COLON
							| test COLON
							| test COLON test
							| test COLON test sliceop
							| test COLON sliceop
							| COLON test
							| COLON test sliceop
							| COLON sliceop
							;
sliceop					::= COLON | COLON test;
exprlist				::= expr | expr COMMA exprlist;
testlist				::= test | test COMMA testlist;
dictorsetmaker			::= test dictmakerclause
							| test setmakerclause
							;
dictmakerclause			::= COLON test
							| COLON test comp_for
							| COLON test test_comma_colon_rec
							;
setmakerclause			::= comp_for | comma_test_rec;
comma_test_rec			::= COMMA test | comma_test_rec test;
test_comma_colon_rec	::= COMMA test COLON test | test_comma_colon_rec COMMA test COLON test;	
classdef				::= CLASS NAME COLON suite
							| CLASS NAME LPAREN RPAREN COLON suite
							| CLASS NAME LPAREN test testlist COLON suite
							;
arglist					::=	argument
							| argument argument_rec
							| MULT test
							| MULT test argument_rec
							| MULT test COMMA MULTMULT test
							| MULT test argument_rec COMMA MULTMULT test
							| MULTMULT test
							| argument argument_rec COMMA MULT test
							| argument argument_rec COMMA MULT test COMMA MULTMULT test
							| argument argument_rec COMMA MULT test argument_rec COMMA MULTMULT test
							| argument argument_rec COMMA MULTMULT test
							;
argument_rec			::= COMMA argument | argument_rec COMMA argument;
//argument_rec			::= argument COMMA | argument COMMA argument_rec;
argument				::= test | test comp_for | test ASSIGN test;

list_iter				::= list_for | list_if;
list_for				::= FOR exprlist IN testlist_safe | FOR exprlist IN testlist_safe list_iter;	
list_if					::= IF old_test | IF old_test list_iter;

comp_iter				::= comp_for | comp_if;
comp_for				::= FOR exprlist IN or_test | FOR exprlist IN or_test comp_iter;
comp_if					::= IF old_test | IF old_test list_iter;
yield_expr				::= YIELD testlist;
												
number					::= FLOAT|IMAGNUM | LONGINT | DECIMAL | HEX | OCT | BIN;