
package pyGrammar;

import java_cup.runtime.*;

parser code
{:
:}

action code
{:
:}

terminal        AND, AS, ASSERT, BREAK, CLASS, CONTINUE;
terminal        DEF, DEL, ELIF, ELSE, EXCEPT, EXEC;
terminal        FINALLY, FOR, FROM, GLOBAL, IF, IMPORT;
terminal        IN, IS, LAMBDA, NOT, OR, PASS;
terminal        PRINT, RAISE, RETURN, TRY, WHILE, WITH;
terminal        YIELD, TRIDOT, DIVDIV;
terminal		PLUS, MINUS, MULT, DIVIDE, MOD, EXPON, DOT, MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ;
terminal		COMMA,SEMI,ASSIGN,COLON,LBRACK,RBRACK,LCURLY,RCURLY,LPAREN,RPAREN,TILDE,ECOM,PIPE,LSHIFT,RSHIFT;
terminal		AT,PLUSEQ,MINUSEQ,MULTEQ,DIVEQ,MODEQ,ANDEQ,OREQ,EXPEQ,RSEQ,LSEQ;
terminal		STRING, DECIMAL, LONGINT, HEX, OCT, BIN,FLOAT,IMAGNUM;
terminal        NAME, NEWLINE, MULTMULT;

non terminal	atom, literal, enclosure,expression, expression_list, exp_recoursive;
non terminal	parenth_form, list_display, list_comprehension, list_for, old_expression_list, old_expression, list_iter, list_if;
non terminal	generator_expression, dict_display, set_display, string_conversion, yield_atom, target_list, or_test, old_lambda_form;
non terminal	comprehension, comp_for, comp_iter, comp_if, expression_nocond;
non terminal	key_datum_list, key_datum,dict_comprehension, yield_expression, attributeref, primary, subscription, slicing, call;
non terminal	long_slice,slice_list,short_slice,simple_slicing,extended_slicing,slice_item,proper_slice,lower_bound,upper_bound,stride,ellipsis;
non terminal	argument_list, positional_arguments, keyword_arguments, keyword_item, genexpr_for;
non terminal	power, u_expr, m_expr, a_expr, shift_expr, and_expr, xor_expr, or_expr, and_test, not_test;
non terminal	file_input, file_input_recoursive, stmt, number, parameter_list, target;
non terminal	comp_recoursive, comparison, comp_operator, conditional_expression, lambda_form, target_list_recoursive;
non terminal	simple_stmt, compound_stmt, del_stmt, print_stmt, return_stmt, yield_stmt, raise_stmt, continue_stmt, global_stmt;
non terminal	expression_stmt, assert_stmt, assignment_stmt, augmented_assignment_stmt, pass_stmt, break_stmt, import_stmt, exec_stmt;


file_input                ::= file_input_recoursive;

file_input_recoursive     ::= NEWLINE file_input_recoursive
                            | stmt file_input_recoursive
                            |
                            ;
stmt                    ::= atom ;

simple_stmt				::= expression_stmt
                 			| assert_stmt
		                 	| assignment_stmt
		                 	| augmented_assignment_stmt
		                	| pass_stmt
		                 	| del_stmt
		                 	| print_stmt
		                 	| return_stmt
			                | yield_stmt
			                | raise_stmt
			                | break_stmt
			                | continue_stmt
			                | import_stmt
			                | global_stmt
			                | exec_stmt
			                ;

/*Statements delle espressioni*/
expression_stmt			::= expression_list;
/*Assignment statement*/
assignment_stmt			::= target_list ASSIGN expression_list
						| target_list ASSIGN yield_expression
						| target_list_recoursive expression_list
						| target_list_recoursive yield_expression
						;
target_list_recoursive	::= target_list ASSIGN | target_list ASSIGN target_list_recoursive;
target_list				::= target | target COMMA target_list;

/*Operazioni booleane*/
or_test			::= and_test | or_test OR and_test;
and_test		::= not_test | and_test AND not_test;
//not_test		::= NOT not_test | comparison;
comparison			::= or_expr | or_expr comp_operator comparison;
comp_operator 		::=  MINOR | MAIOR | EQ | MAIEQ | MINEQ | NEQ
                   		| IS | IS NOT | IN | NOT IN;           
/*
Atoms elementi base delle espressioni. I più semplici
sono identificatori e letterali, anche le espressioni racchiuse
tra parentesi sono considerate atoms.
*/
atom					::= NAME | literal | enclosure;
literal					::= STRING | number;
enclosure 				::=  parenth_form | list_display
	               		| generator_expression | dict_display | set_display
	               		| yield_atom; //string_conversion non so come si faccia, perchè non trovo le reverse quotes
/*lista opzionale di espressioni*/
parenth_form 			::= LPAREN RPAREN | LPAREN expression_list RPAREN;
expression_list			::= exp_recoursive {:System.out.println("found explist"); :};
exp_recoursive			::= expression | expression COMMA exp_recoursive {:System.out.println("exp_recoursive"); :};    

/*list display è una serie di espressioni possibilmente vuote racchiuse in parentesi quadre*/
list_display        ::=  LBRACK RBRACK | LBRACK expression_list RBRACK | LBRACK list_comprehension RBRACK;
list_comprehension  ::=  expression list_for;
list_for            ::=  FOR target_list IN old_expression_list | FOR target_list IN old_expression_list list_iter ;
old_expression      ::=  or_test | old_lambda_form;
old_expression_list ::=  old_expression | old_expression COMMA old_expression_list;
list_iter           ::=  list_for | list_if;
list_if             ::=  IF old_expression | IF old_expression list_iter;

/*
Per costruire un insieme o un dizionario Python fornisce una sintassi speciale chiamata "displays".
Ciascuno dei quali in due gusti: i contenuti sono elencati esplicitamente, oppure
essi sono calcolato tramite un set di ciclo e di istruzioni di filtraggio chiamate comprehension.
La comprehension consiste di una singola espressione seguita da almeno una clausa for e uno o più costrutti for o if
*/
comprehension ::=  expression comp_for;
comp_for      ::=  FOR target_list IN or_test | FOR target_list IN or_test comp_iter;
comp_iter     ::=  comp_for | comp_if;
comp_if       ::=  IF expression_nocond | IF expression_nocond comp_iter;

generator_expression ::=  LPAREN expression comp_for RPAREN;
/*
Serie di coppie chiave-valore tra parentesi graffe
*/
dict_display       	::=  LCURLY RCURLY | LCURLY key_datum_list RCURLY | LCURLY dict_comprehension RCURLY ;
key_datum_list     	::=  key_datum | key_datum COMMA key_datum_list | key_datum COMMA;
key_datum          	::=  expression COLON expression ;
dict_comprehension 	::=  expression COLON expression comp_for;

yield_atom       	::=  LPAREN yield_expression RPAREN;
yield_expression 	::=  YIELD | YIELD expression_list;

/*Un set display è denotato dalle parentesi graffe, ma a differenza del dizionario, non vi è la virgola tra chiave e valore*/
set_display 		::=  LCURLY expression_list RCURLY | LCURLY comprehension RCURLY;

/*Le primaries rappresentano le operazioni più strettamente limitate del linguagio*/
primary				::= atom | attributeref | subscription | slicing | call;
attributeref 		::=  atom DOT NAME
					| subscription DOT NAME
					| slicing DOT NAME
					| call DOT NAME
					;
/*una subscription seleziona un oggetto di una sequenza o di un dizionario*/
subscription ::=  primary LBRACK expression_list RBRACK;
/*Uno slicing seleziona un intervallo di oggetti in una sequenza*/
slicing          	::=  simple_slicing | extended_slicing;
simple_slicing   	::=  primary LBRACK short_slice RBRACK;
extended_slicing 	::=  primary LBRACK slice_list RBRACK;
slice_list			::=	 slice_item | slice_item COMMA | slice_list;//slice_list       	::=  slice_item ("," slice_item)* [","]
slice_item       	::=  expression | proper_slice | ellipsis;
proper_slice     	::=  short_slice | long_slice;
short_slice			::=  lower_bound COLON upper_bound; //short_slice      	::=  [lower_bound] COLON [upper_bound]
long_slice       	::=  short_slice COLON | short_slice COLON stride;
lower_bound      	::=  expression;
upper_bound      	::=  expression;
stride           	::=  expression;
ellipsis         	::=  TRIDOT;

/*Calls serve per chiamare gli oggetti come funzioni con una serie di parametri*/
//call                 ::=  primary "(" [argument_list [","] | expression genexpr_for] ")"
call                 ::=  primary LPAREN RPAREN 
						| primary LPAREN argument_list RPAREN 
						| primary LPAREN argument_list COMMA RPAREN 
						| primary LPAREN expression genexpr_for RPAREN;

/*
argument_list    ::=  positional_arguments ["," keyword_arguments] ["," "*" expression] ["," keyword_arguments] ["," "**" expression]
                          | keyword_arguments ["," "*" expression]
                            ["," "**" expression]
                          | "*" expression ["," "*" expression] ["," "**" expression]
                          | "**" expression
*/

argument_list        ::=  positional_arguments
						| positional_arguments COMMA keyword_arguments
						| positional_arguments COMMA MULT expression
						| positional_arguments COMMA keyword_arguments COMMA MULT expression COMMA keyword_arguments
						| positional_arguments COMMA MULTMULT expression
						| positional_arguments COMMA keyword_arguments COMMA MULT expression COMMA keyword_arguments COMMA MULTMULT expression
						| keyword_arguments | keyword_arguments COMMA MULT expression | keyword_arguments COMMA MULTMULT expression | keyword_arguments COMMA MULT expression COMMA MULTMULT expression
						| MULT expression | MULT expression COMMA MULT expression | MULT expression COMMA MULTMULT expression | MULT expression COMMA MULT expression COMMA MULTMULT expression
						| MULTMULT expression
						;
positional_arguments ::=  expression | expression COMMA positional_arguments;
keyword_arguments    ::=  keyword_item | keyword_item COMMA keyword_arguments;
keyword_item         ::=  NAME ASSIGN expression;

/*Operatori di elevamento a potenza*/
power				::= primary | primary EXPON u_expr;
/*Operazioni di shifting*/
shift_expr			::= a_expr | shift_expr LPAREN LSHIFT RPAREN a_expr
						| shift_expr LPAREN RSHIFT RPAREN a_expr
						;
						
/*Operazioni condizionali*/
conditional_expression	::= or_test	| or_test IF or_test ELSE expression;

expression				::= conditional_expression | lambda_form;	
lambda_form				::= LAMBDA COLON expression
							| LAMBDA parameter_list COLON expression;
old_lambda_form 		::= LAMBDA COLON old_expression
							| LAMBDA parameter_list COLON old_expression;
							
target					::= NAME
						| LPAREN target_list RPAREN
						| LBRACK target_list RBRACK
						//| attributeref
						//| subscription
						//| slicing
						;

/*Operazioni binarie bit a bit*/
and_expr			::= shift_expr | and_expr AND shift_expr;
xor_expr			::= and_expr | xor_expr EXPON and_expr;
or_expr				::= xor_expr | or_expr OR xor_expr;    		
/*operatori unari*/
u_expr				::= power | MINUS u_expr | PLUS u_expr | TILDE u_expr;
/*Operatori binari*/
m_expr 			::=  u_expr | m_expr MULT u_expr | m_expr DIVDIV u_expr | m_expr DIVIDE u_expr
            		| m_expr MOD u_expr;
a_expr 			::=  m_expr | a_expr PLUS m_expr | a_expr MINUS m_expr;

number					::= FLOAT |IMAGNUM | LONGINT | DECIMAL | HEX | OCT | BIN ;