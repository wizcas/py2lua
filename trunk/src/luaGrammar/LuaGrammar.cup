
package luaGrammar;

import java_cup.runtime.*;

parser code
{:
:}

action code
{:
:}

terminal		VAR_NAME,ASSIGN, INT, FLOAT,EXP, HEX, COMMENT, WS, NEWLINE, LINE_COMMENT; 
terminal		SEMI,COMMA,DOT,NORMALSTRING,CHARSTRING,LONGSTRING;
terminal		PLUS, MINUS, MULT, DIVIDE, MOD, EXPON, DOTDOT;
terminal		MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ, AND, OR, NIL;
terminal		NOT, FALSE, TRUE, TRIDOT, SHARP, COLON;
terminal		LPAREN, RPAREN, LBRACK, RBRACK, LCURLY, RCURLY;
terminal		FUNCTION, WHILE,FOR,DO,END,REPEAT,UNTIL,IF,ELSEIF,THEN,ELSE,LOCAL,RETURN,BREAK,IN;

non terminal	chunk, block, stat, statement, expr, exp, expressions, binop, unop, last_stat;
non terminal	number, string, explist, funcbody, function, funcname, parlist, functioncall, fieldlist, fieldsep, field_member;
non terminal	prefixexp, var,var_suffix,var_suffix_rec, name_and_args,args, varlist, var_recourse, var_or_exp, field, tableconstructor, explist_member, stat_recourse;
non terminal	stat_recoursive, var_recoursive, exp_member, exp_recoursive, exp_member_recoursive , namelist;
non terminal	return_stat, for_stat, if_stat, if_recoursive, dot_var_name;


/*Precedenza operatori: 
	or
     and
     <     >     <=    >=    ~=    ==
     .. (rigth associative)
     +     -
     *     /     %
     not   #     - (unary)
     ^ (rigth associative)
*/
precedence left OR;
precedence left AND;
precedence left MINOR, MINEQ, MAIOR, MAIEQ, EQ, NEQ;
precedence right DOTDOT;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, MOD;
precedence left NOT, SHARP;
precedence right EXPON;

/*unità operativa di Lua, composto da una sequenza di statement seguiti opzionalmente da un ;*/
chunk			::= stat_recoursive
				| stat_recoursive last_stat
				|
				;
stat_recoursive ::= stat
				| stat SEMI	
				| stat stat_recoursive
				| stat SEMI stat_recoursive
				;
/* un blocco è una lista di statement, sintatticamente è come un chunk*/
block			::= chunk;
/*un blocco può essere esplicitamente delimitato per produrre un singolo statement*/
stat			::= varlist ASSIGN explist {:System.out.println("varlist assign explist");:} /*Lua consente assegnazioni multiple*/
				| functioncall
				| DO block END
				| WHILE exp DO block END /*costrutti if while e repeat*/
				| REPEAT block UNTIL exp
				| if_stat
				| for_stat
				| FUNCTION funcname funcbody
				| LOCAL FUNCTION VAR_NAME funcbody
				| LOCAL namelist
				| LOCAL namelist ASSIGN explist
				;
if_stat			::= IF exp THEN block END
				| IF exp THEN block if_recoursive END
				| IF exp THEN block ELSE block END
				| IF exp THEN block if_recoursive ELSE block END
				;
if_recoursive	::= ELSEIF exp THEN block 
				| ELSEIF exp THEN block if_recoursive;
/*ripete un blocco di codice incrementando la prima variabile che parte dalla prima exp
fino alla seconda exp, incrementandosi della terza exp che è opzionale
Oppure può ciclare in base ad una lista di nomi all'interno di una tabella*/
for_stat		::= FOR VAR_NAME ASSIGN exp COMMA exp DO block END {:System.out.println("for stat");:}
				| FOR VAR_NAME ASSIGN exp COMMA exp COMMA exp DO block END
				| FOR namelist IN explist DO block END {:System.out.println("for stat in");:}
				;
last_stat		::= RETURN | RETURN explist | BREAK
				| RETURN SEMI | RETURN explist SEMI | BREAK SEMI
				;
funcname		::= VAR_NAME dot_var_name
				| VAR_NAME dot_var_name COLON VAR_NAME
				;
dot_var_name	::= | DOT VAR_NAME dot_var_name;
varlist			::= var {:System.out.println("varlist->var");:} | var COMMA varlist;
/*un singolo nome denota una variabile,
le parentesi quadre denotano l'indice di una tabella,
una pillola sintattica per ritornare l'elemento di una tabella
è tabella.nome che sta per ["nome"]
*/
var				::= VAR_NAME {:System.out.println("found varname");:}
				| prefixexp LBRACK exp RBRACK
				| prefixexp DOT VAR_NAME {:System.out.println("found var->pref dot varname");:}
				;
namelist		::= VAR_NAME | COMMA VAR_NAME namelist;
explist			::= exp_recoursive {:System.out.println("found explist"); :};
exp_recoursive	::= exp | exp COMMA exp_recoursive;
/*
le espressioni che seguono servono per matchare: exp_member (binop exp_member)* e quindi binop exp_member va messo ricorsivo
*/
exp				::= exp_member_recoursive;
exp_member_recoursive ::= exp_member | exp_member binop exp_member_recoursive;
exp_member		::= NIL | FALSE | TRUE
				| number {:System.out.println("found number");:}
				| string
				| function
				| prefixexp
				| tableconstructor
				| TRIDOT
				| unop exp_member
				;
prefixexp		::= var {: System.out.println("prefixexp->var"); :} | functioncall {: System.out.println("prefixexp->functioncall"); :}; //manca | LPAREN exp RPAREN;
/* la forma base sarebbe "prefixexp args"
si usa "prefix : Name args" per chiamare metodi, infatti esso
v:name(args) è l'equivalente di chiamare v.name(v,args) solo che v
viene valutato solo una volta.
*/
functioncall	::= prefixexp args {:System.out.println("function call"); :} | prefixexp COLON VAR_NAME args {:System.out.println("function call"); :};
/*
per gli argomenti, la chiamata f{fields} è equivalente a f({fields})
oppure per chiamare una sringa per argomento f"string", f'string', f[[string]]
sono equivalenti a f("string")
*/
args			::= LPAREN RPAREN {:System.out.println("args ()"); :}
				| LPAREN explist RPAREN {:System.out.println("args (explist)"); :}
				| tableconstructor
				| string
				;
function		::= FUNCTION funcbody;
funcbody		::= LPAREN RPAREN block END
				| LPAREN parlist RPAREN block END
				;
parlist			::= namelist
				| namelist COMMA TRIDOT
				| TRIDOT
				;
tableconstructor ::= LCURLY RCURLY | LCURLY fieldlist RCURLY {: System.out.println("table constructor");:};
fieldlist		::= field {:System.out.println("found a field"); :} 
				| field fieldsep fieldlist {:System.out.println("found fieldlist"); :}
				;
field			::= LBRACK exp RBRACK ASSIGN exp
				| VAR_NAME ASSIGN exp
				| exp
				;
fieldsep		::= SEMI | COMMA;
binop 			::= PLUS | MINUS | MULT | DIVIDE | EXPON | MOD | DOTDOT
		 		| MINOR | MINEQ | AND | OR
		 		;
unop		::= MINUS | NOT | SHARP; 
number		::= EXP {:System.out.println("found EXP"); :} 
			| FLOAT {:System.out.println("found FLOAT"); :} 
			| INT {:System.out.println("found INT"); :};
string		::= NORMALSTRING | CHARSTRING|LONGSTRING;


/*                      
comment				::= COMMENT
                      | LINE_COMMENT
                      ;
*/